<!--
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../../core-asset/core-asset.html">
<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../../src/commands/commands.html">
<link rel="import" href="../../src/css/css.html">
<link rel="import" href="../designer-selection/designer-selection.html">

<dom-module id="designer-stage">

  <style>
    :host {
      display: block;
      box-sizing: border-box;
      position: relative;
    }
    iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
      box-sizing: border-box;
      background: gray;
    }
    #glass {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 100;
    }
    designer-selection {
      position: absolute;
      z-index: 102;
    }
    #hover {
      position: absolute;
      /* z-index must be > 100 because iframes are z-index 100 o_O */
      z-index: 101;
      display: none;
      opacity: 0.5;
      background: #c66;
      box-sizing: border-box;
    }
    #hover.insert-above {
      border-top: solid 4px black;
    }
    #hover.insert-below {
      border-bottom: solid 4px black;
    }

  </style>

  <template>
    <designer-selection id="selection" on-click="_onSelectionClick"></designer-selection>
    <div id="hover"></div>
    <div id="glass" on-mousedown="_onMouseDown"></div>
  </template>

  <core-asset id="frame-script" href="frame.js"></core-asset>

</dom-module>

<script>
  define(['Commands'], function(commands) {
    'use strict';

    /**
     * `<designer-stage>` is a WYSIWYG editing surface and container for
     * an HTML document.
     *
     * @typedef {{
     *   path: string,
     *   tagName: string,
     *   display: string,
     *   position: string,
     * }} CurrentElementInfo
     */
    Polymer({
      is: 'designer-stage',

      properties: {

        /**
         * @type {CurrentElementInfo}
         */
        currentElementInfo: {
          type: Object,
          notify: true,
          value: null,
        },

        /**
         * @type {string}
         */
        token: {
          type: String,
          value: null,
        },

        /**
         * @type {{x: number, y: number}}
         */
        currentMousePosition: {
          type: Object,
          value: null,
        },

        insertPosition: {
          type: String,
          value: null,
        },

        hoverPath: {
          type: String,
          value: null,
        }
      },

      ready() {
        window.addEventListener('message', this._onMessage.bind(this));
        this.$.selection.addEventListener('designer-selection-resize',
            this._onSelectionResize.bind(this));

        window.addEventListener('mouseup', this._onMouseUp.bind(this));

        var token = this.token = this._generateToken();
        this._reset();
      },

      _reset() {
        this.currentElementInfo = null;
        this.currentMousePosition = null;
        this.insertPosition = null;
        this.hoverPath = null;
        this._hideHover();
        this.$.selection.style.display = 'none';
      },

      /**
       * @returns {Promise<Document>} The modified document with an injected
       * <script> tag for the message handler.
       */
      setDocument(content) {
        var module = document.createElement('dom-module');
        var frameScriptAsset = module.import('designer-stage', '#frame-script');

        this._reset();

        return frameScriptAsset.load()
          .then((function(frameScript) {
            // Return a new Promise so we can resolve/reject on load/error
            // events from the frame
            return new Promise((function(resolve, reject) {
              var frame = this._getFrame();
              if (frame != null) {
                Polymer.dom.removeChild(frame, this);
              }
              frame = document.createElement('iframe');
              frame.setAttribute('id', 'frame');
              frame.setAttribute('sandbox', 'allow-scripts');
              Polymer.dom.appendChild(frame, this);

              // create an HTML document from the content
              var doc = document.implementation.createHTMLDocument();

              doc.documentElement.innerHTML = content;

              // insert a script tag with the frame.js source
              var frameScriptElement = doc.createElement('script');
              frameScriptElement.textContent = frameScript;
              doc.head.insertBefore(frameScriptElement, doc.head.firstChild);

              // data: URIs need a base for relative URLs
              var base = doc.createElement('base');
              base.setAttribute('href', this.baseURI);
              doc.head.insertBefore(base, doc.head.firstChild);

              // set the iframe src to the new document
              var docBlob = new Blob([doc.documentElement.innerHTML],
                  {type: 'text/html'});
              frame.src = URL.createObjectURL(docBlob);

              // listen to load and error events from the frame
              var onFrameLoad = (function() {
                frame.contentWindow.postMessage({
                  messageType: 'handshake',
                  token: this.token
                }, '*');
                frame.removeEventListener(onFrameLoad);
                frame.removeEventListener(onFrameError);
                resolve({document: doc, content: content});
              }).bind(this);
              frame.addEventListener('load', onFrameLoad);

              var onFrameError = (function(e) {
                if (e.type == 'load') {
                  console.warn("<designer-stage> error loading frame contents");
                }
                frame.removeEventListener(onFrameLoad);
                frame.removeEventListener(onFrameError);
                reject("<designer-stage> error loading frame contents");
              }).bind(this);
              frame.addEventListener('error', onFrameError);

            }).bind(this));
          }).bind(this));
      },

      selectNode(path) {
        this._sendSelectElementAtPath(path);
      },

      _getFrame() {
        return Polymer.dom.querySelector('iframe', this);
      },

      dispatchCommand(command) {
        this._getFrame().contentWindow.postMessage(command, "*");
        this.dispatchEvent(new CustomEvent('designer-command', {
          detail: command,
        }));
      },

      _generateToken() {
        var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        var token = '';
        for (var i = 0; i < 16; i++) {
          token += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        }
        return token;
      },

      _onMessage(e) {
        if (e.data.token != this.token) {
          throw new Error('Invalid message token', token);
        }
        var messages = e.data.messages;
        for (var i = 0; i < messages.length; i++) {
          var message = messages[i];
          switch (message.messageType) {
            case 'selectionBoundsChange':
              this._onSelectionBoundsChange(message);
              break;
            case 'newSelection':
              this._onNewSelection(message);
              break;
            case 'hoverElement':
              this._onHoverElement(message);
              break;
            case 'command':
              this._onCommand(message);
              break;
            default:
              console.warn('<designer-stage> Unknown message type: ',
                  message.messageType);
          }
        }
      },

      _onCommand(message) {
        this.dispatchEvent(new CustomEvent('designer-command', {
          detail: message,
        }));
      },

      _onSelectionBoundsChange(message) {
        var style = this.$.selection.style;
        style.display = 'block';
        style.top = message.top + 'px';
        style.left = message.left + 'px';
        style.width = message.width + 'px';
        style.height = message.height + 'px';
      },

      _onNewSelection(message) {
        // Set the valid resize handles
        var position = message.position;
        var display = message.display;

        if (position === 'static' || position === 'relative') {
          if (display === 'block') {
            selection.directions = ResizeDirection.WIDTH_HEIGHT;
          } else if (display === 'inline') {
            selection.directions = [];
          }
        } else if (position === 'absolute') {
          selection.directions = ResizeDirection.ALL_DIRECTIONS;
        } else {
          console.warn("can't handle position", data.position);
          selection.directions = [];
        }

        // TODO(nevir): This indirection seems overkill. This is, I think,
        // **always** going to be message without the `messageType` property.
        // We should just pass it through. Messages over the wire might be
        // better wrapped.
        this.currentElementInfo = {
          path: message.path,
          tagName: message.tagName,
          display: message.display,
          position: message.position,
          styles: message.styles,
          computedStyle: message.computedStyle,
        };
      },

      _onHoverElement(message) {
        var hover = this.$.hover;
        var hoverStyle = hover.style;

        if (message.path == null) {
          this._hideHover();
          return;
        } else {
          hoverStyle.display = 'block';
          hoverStyle.top = message.top + 'px';
          hoverStyle.left = message.left + 'px';
          hoverStyle.width = message.width + 'px';
          hoverStyle.height = message.height + 'px';
        }

        if (this.currentElementInfo &&
            this.currentElementInfo.position == 'static') {
          var verticalMid = message.top + message.height / 2;
          var insertAbove = this.currentMousePosition.y < verticalMid;
          var insertBelow = this.currentMousePosition.y > verticalMid;

          if (insertAbove) {
            hover.classList.add('insert-above');
            this.insertPosition = commands.InsertPosition.before;
            this.hoverPath = message.path;
          } else {
            hover.classList.remove('insert-above');
          }
          if (insertBelow) {
            hover.classList.add('insert-below');
            this.insertPosition = commands.InsertPosition.after;
            this.hoverPath = message.path;
          } else {
            hover.classList.remove('insert-below');
          }
        }
      },

      _hideHover() {
        var hover = this.$.hover;
        var hoverStyle = hover.style;
        hoverStyle.display = 'none';
        this.insertPosition = null;
        this.hoverPath = null;
      },

      _onSelectionResize(e) {
        // TODO: store this in the selection?
        // Rationale: we're alredy storing the bounds state there
        this.currentMousePosition = {
          x: e.detail.cursor.x - this.offsetLeft,
          y: e.detail.cursor.y - this.offsetTop,
        };
        this._getFrame().contentWindow.postMessage({
          messageType: 'selectionChange',
          bounds: e.detail.bounds,
          cursor: this.currentMousePosition,
        }, '*');
      },

      _onMouseDown(e) {
        this._sendSelectElementAtPoint(e.clientX, e.clientY);
      },

      _onMouseUp(e) {
        if (this.hoverPath != null && this.insertPosition != null) {
          this.dispatchCommand(
            commands.moveElement(
              this.currentElementInfo.path,
              this.hoverPath,
              this.insertPosition));
        }
        this._hideHover();
      },

      _onSelectionClick(e) {
        this._sendSelectElementAtPoint(e.clientX, e.clientY);
      },

      _sendSelectElementAtPoint(clientX, clientY) {
        var bounds = this.getBoundingClientRect();
        var x = clientX - bounds.left;
        var y = clientY - bounds.top;
        this._getFrame().contentWindow.postMessage({
          messageType: 'selectElementAtPoint',
          x: x,
          y: y
        }, "*");
      },

      _sendSelectElementAtPath(path) {
        var frame = this._getFrame();
        if (frame == null) return;
        frame.contentWindow.postMessage({
          messageType: 'selectElementAtPath',
          path: path,
        }, "*");
      },

    });

  });
</script>

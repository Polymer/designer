<link rel="import" href="../../components/polymer/polymer.html">

<polymer-element name="x-designable" designer attributes="selected" on-keydown="{{keydown}}" on-pointerdown="{{pointerDown}}" on-pointerup="{{pointerUp}}" on-trackstart="{{trackStart}}" on-track="{{track}}" on-trackend="{{trackEnd}}">

<template>

  <style>
    :host {
      position: relative;
      outline: none;
      background-image: url(grid.png);
      -webkit-user-select: none
    }
  </style>

  <content></content>

</template>
<script>
(function() {

  // turn on binding reflection;
  Platform.enableBindingsReflection = true;

  Polymer('x-designable', {

    grid: 10,
    selected: null,

    ready: function() {
      this.meta = document.createElement('x-meta');
    },

    // communication
    notify: function() {
      this.fire('design-change', this);
    },

    // state
    selectedChanged: function(old) {
      this.classFollows(this.selected, old, 'selected-element');
      if (this.selected) {
        this.ruleForElement(this.selected);
      }
      this.notify();
    },

    // commands
    deleteElement: function() {
      var e = this.selected;
      if (e && e !== this) {
        //if (e === this.$.designElement) {
        //  this.clearElement();
        //} else {
          e.parentNode.removeChild(e);
          forSubtree(e, this.removeElementRule.bind(this));
          this.selected = null;
        //}
      }
    },

    selectParentElement: function() {
      var e = this.selected;
      if (e && e.parentNode) {
        e = e.parentNode;
        if (e === this) {
          e = null;
        }
        this.selected = e;
      }
    },

    update: function() {
      this.marshalNodeReferences(this);
    },

    //
    // abstracted drag API
    //
    // `track` events are triggered at the source of the drag, so 
    // any object that wants to support dragging 'designable' objects
    // implements the 'track' events but delegates the work to 
    // callbacks that 'drag' populates on the drag object (dragInfo).
    //
    // drag-sources are x-pallete and x-designable
    //
    drag: function(dragInfo) {
      // TODO(sjmiles): store in instance variable?
      this.dragInfo = dragInfo;
      // drag avatar
      // TODO(sjmiles): if this is an element from the design-canvas, it's immediately
      // pulled out of it's original context
      if (dragInfo.element.parentNode != this) {
        this.appendChild(dragInfo.element);
      }
      //
      // calculate a starting origin in the frame of 'this'
      var local = this.getBoundingClientRect();
      // TODO(sjmiles): why the conditional?
      var origin = dragInfo.origin; // || dragInfo.element.getBoundingClientRect();
      dragInfo.start = {x: origin.left - local.left, y: origin.top - local.top};
      //console.log(origin, dragInfo.start, local);
      //
      // contextualize utility method
      var snap = this.snap.bind(this);
      var ruleForElement = this.ruleForElement.bind(this);
      // attach drag handler to the dragInfo
      dragInfo.drag = function(event) {
        var p = snap(
          this.start.x + event.dx,
          this.start.y + event.dy
        );
        var rule = ruleForElement(this.element);
        rule.style.left = p.x + 'px';
        rule.style.top = p.y + 'px';
      };
    },

    drop: function(element, event) {
      this.style.overflow = 'hidden';
      var container = this.findContainer(element, event.target);
      if (container && this.canContain(container, element)) {
        // don't manipulate parentNode if not necessary
        var sameParent = (container === element.parentNode);
        if (!sameParent) {
          // install element in container
          container.appendChild(element);
        }
        this.decorateElement(element);
        // ideally we only notify one change on drop
        // the selection changing will cause a notify
        // if the selection is not changing, but we
        // did change the hierarchy, notify manually
        if (!sameParent && this.selected === element) {
          this.notify();
        }
        this.selected = element;
        return true;
      }
    },

    decorateElement: function(element) {
      var s = this.ruleForElement(element).style;
      s.pointerEvents = null;
      s.transition = null;
      s.webkitTransition = null;
      // designer is absolutely positioned, ad-hoc
      s.position = 'absolute';
      if (element.parentNode !== this) {
        s.left = s.top = s.position = '';
      }
      var self = this;
      function decorate(element) {
        self.applyUniqueId(element);
        self.ruleForElement(element);
      }
      Array.prototype.filter.call(element.children, function(c) {
          return ['style'].indexOf(c.localName) < 0;
        }).forEach(decorate);
    },

    // stuffs required for making binding to work, ad-hoc
    applyUniqueId: function(node) {
      if (!node.id) {
        node.id = this.makeUniqueId(this, node.localName
          .replace(/^g-/, '').replace(/-/g, '_'));
      }
    },

    makeUniqueId: function(node, id, suffix) {
      var uId = id + (suffix || '');
      // TODO(sorvell): why the polyfill intrusion?
      var query = window.ShadowDOMPolyfill ? node.impl.querySelector :
        node.querySelector;
      var scope = window.ShadowDOMPolyfill ? document.body : node;
      return query.call(scope, '#' + uId) ?
        this.makeUniqueId(node, id, suffix ? ++suffix : 1) :
        uId;
    },

    applyPropertyBinding: function(target, name, path) {
      if (name === 'textContent') {
        if (path) {
          target.textContent = ' ';
          target = target.firstChild;
        } else {
          target.firstChild.unbind(name);
        }
      } else {
        this.unbindElementProperty(target, name);
        target.removeAttribute(name);
      }
      if (path) {
        target.bind(name, new PathObserver(this, path));
      }
    },

    // Node.bind no longer provides unbinding but we need this concept
    // here so we unbind by closing the bound observer.
    unbindElementProperty: function(target, name) {
      if (target.bindings_ && target.bindings_[name]) {
        target.bindings_[name].close();
        target.bindings_[name] = null;
      }
    },

    // events
    keydown: function(event) {
      switch(event.keyCode) {
        case 27:
          this.selectParentElement();
          break;
        case 8:
        case 46:
          if (!this.nodeIsEditor(event.target)) {
            this.deleteElement();
            event.preventDefault();
          }
          break;
      }
    },

    pointerDown: function(e) {
      //this.dragDisabled = e.altKey;
    },

    pointerUp: function(e) {
      if (this.dragInfo && !this.dragInfo.dropped) {
        this.dragInfo.dropped = this.drop(this.dragInfo.element, e);
      } else {
        this.selected = e.target;
      }
      this.dragInfo = null;
      //var focusNode = nodeIsEditor(this.selected) ? this.selected : this;
      //focusNode.focus();
    },

    trackStart: function(event) {
      // it's nobody else's event
      event.stopPropagation();
      //console.dir(event);
      // acquire target
      if (this.dragDisabled) {
        return;
      }
      var elt = this.findDraggableElement(event.target);
      if (elt) {
        var dragInfo = this.createDragObject(elt);
        //
        var px = event.pageX - dragInfo.origin.left;
        if (px < 4 || px > dragInfo.origin.width -4) {
          console.log(px);
          return;
        }
        //
        this.makeElementDraggable(elt);
        //
        this.drag(dragInfo);
        this.selected = elt;
        //Platform.flush();
      }
    },

    track: function(event) {
      if (this.dragInfo && this.dragInfo.drag) {
        this.dragInfo.drag(event);
      }
    },

    trackEnd: function(event) {
      if (this.dragInfo) {
        event.stopPropagation();
        //this.drop(this.dragInfo.element, event);
        // TODO(sorvell): delete if we drag out of canvas area
        // we'll need to refine this when dragging onto the tree becomes
        // supported.
        this.deleteElement();
        this.dragInfo = null;
      }
    },

    // utility
    makeElementDraggable: function(element) {
      var s = this.ruleForElement(element).style;
      s.position = 'absolute';
      s.pointerEvents = 'none';
      s.transition = 'none';
      s.webkitTransition = 'none';
      // show elements
      this.style.overflow = null;
    },

    findContainer: function(element, container) {
      while (container) {
        if (container === this || element !== container && container.meta && container.meta.isContainer) {
          return container;
        }
        container = container.parentNode;
      }
    },

    canContain: function(container, element) {
      var filter = container.meta && container.meta.childFilter;
      return (!filter || filter(elt));
    },

    findDraggableElement: function(target) {
      // nominal target
      var elt = target;
      // try to match selection on drag
      if (this.selected) {
        while (elt && elt !== this && elt !== this.selected) {
          elt = elt.parentNode;
        }
      }
      // when no selection match, auto-select top-level element
      if (elt !== this.selected) {
        // nominal target
        elt = target;
        // find top level parent
        while (elt && elt.parentNode !== this) {
          elt = elt.parentNode;
        }
      }
      // don't drag designer itself
      if (elt === this) {
        elt = null;
      }
      // return result
      return elt;
    },

    createDragObject: function(elt) {
      var rect = elt.getBoundingClientRect();
      return {
        origin: rect,
        element: elt
      };
    },

    snap: function(inX, inY) {
      return {
        x: Math.round(inX / this.grid) * this.grid,
        y: Math.round(inY / this.grid) * this.grid
      }
    },

    nodeIsEditor: function(node) {
      return (node.meta && node.meta.isEditor) || this.editorElements[node.localName];
    },

    editorElements: {input: 1, select: 1, textarea: 1},

    loadHtml: function(html) {
      // TODO(sorvell): what should we bind to? for right now, we bind
      // to 'this', but we should bind to some element that we're designing...
      var template = document.createElement('template');
      template.bindingDelegate = this.syntax;
      template.innerHTML = html;
      this.sanitizeContent(template.content);
      this.innerHTML = '';
      // make imports go...
      this.loadElementImports(template.content, function() {
        this.appendChild(template.createInstance(this));
        executeScriptsInScope(this);
        this.meta.ensureMeta(this);
        this.update();
        this.notify();
      }.bind(this));
    },

    sanitizeContent: function(element) {
      // remove imports so that we don't have to keep track of them
      var imports = element.querySelectorAll('link[rel=import]').array();
      imports.forEach(function(i) {
        i.remove();
      });
    },

    loadElementImports: function(element, callback) {
      var pending = 1;
      var receive = function() {
        pending--;
        checkDone();
      }
      var checkDone = function() {
        if (pending == 0 && callback) {
          callback();
        }
      };
      var n$ = element.querySelectorAll('*');
      for (var i=0, l=n$.length, n, m; (i<l) && (n=n$[i]); i++) {
        m = this.meta.byId(n.localName);
        if (m && !m.importsLoaded) {
          pending++;
          m.loadImports(receive);
        }
      }
      receive();
    },

    setupStyleElement: function() {
      var s = this.querySelector('style');
      if (!s) {
        s = document.createElement('style');
        s.textContent = ' ';
        this.insertBefore(s, this.firstElementChild);
      }
      this.styleElement = s;
    },

    ruleForElement: function(element) {
      return element.__styleRule || (element.__styleRule = 
          this.findElementRule(element));
    },

    findElementRule: function(element) {
      if (!this.styleElement) {
        this.setupStyleElement();
      }
      if (!element.id) {
        this.applyUniqueId(element);
      }
      var re = new RegExp('#' + element.id + '(\\s|{)');
      var sheet = this.styleElement.sheet;
      var rules = sheet.cssRules;
      var i = this.indexOfRule(rules, '#' + element.id);
      if (i < 0) {
        i = rules.length;
      }
      if (!rules[i]) {
        sheet.insertRule('#' + element.id + '{' + element.style.cssText + '}',
          i);
      }
      element.style.cssText = '';
      return rules[i];
    },

    removeElementRule: function(element) {
      var sheet = this.styleElement.sheet, rules = sheet.cssRules;
      var i = this.indexOfRule(rules, '#' + element.id);
      if (i >= 0) {
        sheet.deleteRule(i);
      }
    },

    indexOfRule: function(rules, selector) {
      for (var i=0, l=rules.length; i < l; i++) {
        if (rules[i].selectorText == selector) {
          return i;
        }
      }
      return -1;
    }

  });

  function executeScriptsInScope(scope) {
    // make scripts go....
    var s$ = scope.querySelectorAll('script:not([src])');
    for (var i=0, l=s$.length, s; (i<l) && (s=s$[i]); i++) {
      replaceAndExecuteScript(s);
    }
  }

  function replaceAndExecuteScript(script) {
    var newScript = document.createElement('script');
    script.parentNode.replaceChild(newScript, script);
    newScript.textContent = script.textContent;
  }

  function cssTextFromStyle(style) {
    var sheet = style && style.sheet;
    if (sheet) {
      var rules = sheet.cssRules;
      for (var i=0, css=[]; i < rules.length; i++) {
        css.push(rules[i].cssText);
      }
      return css.join('\n\n');
    }
  }

  function forSubtree(element, callback) {
    if (callback) {
      callback(element);
      var element = element.firstElementChild;
      while (element) {
        forSubtree(element, callback);
        element = element.nextElementSibling;
      }
    }
  }
    
})();
</script>

</polymer-element>